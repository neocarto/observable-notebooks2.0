import{ag as isgeojson,ah as isarrayofobjects,ai as geosloader,aj as isemptygeom,ak as e,al as geomtypes,am as check,Z as geoStitch,M as geoCircle,an as geojsonPrecisionExports,ao as o,ap as togeojson,aq as str2fun}from"./buffer-BsOFDvqg.js";import{aA as F,as as C,ax as N,ay as k,aC as A,az as J,aB as P,ar as I,at as M,aw as L,a8 as R,af as q,av as V,au as $}from"./buffer-BsOFDvqg.js";async function iterate(r,{func:s=n=>n,mutate:t=!1}={}){let n=r;return isgeojson(n)?(t||(n=JSON.parse(JSON.stringify(r))),n.features=await Promise.all(n.features.map(i=>Promise.resolve(s(i))))):isarrayofobjects(n)&&(n=await Promise.all(n.map(i=>Promise.resolve(s(i)))),t&&r.splice(0,r.length,...n)),n}function htmltable(r,{maxrows:s=null}={}){let t,n=isgeojson(r);n?t=r.features.map(d=>Object.assign({GEOMETRY:d?.geometry?.type},d.properties)):t=r;let i=document.createElement("table"),a=document.createElement("thead"),c=document.createElement("tr");const l=Object.keys(t[0]);l.forEach((d,O)=>{const w=t.map(v=>v[d]),S=w.length;console.log(w);const E=w.filter(v=>![""," ","  ",void 0,NaN,null,1/0,-1/0].includes(v)).length;let g=document.createElement("th");g.innerHTML=d+`<span style='font-size: 0.7em; font-style: italic ; font-weight: normal; color: #808080'><br/>${E}/${S}</span>`,g.style.cursor="pointer",g.style.backgroundColor="white",g.style.color="#444",g.style.padding="10px",g.style.textAlign="left",g.style.position="sticky",g.style.top="0",g.style.zIndex="1",g.style.borderBottom="2px solid #444",g.style.fontSize="1em";let h=!0;g.addEventListener("click",()=>{h=!h,m(O,h)}),c.appendChild(g)}),a.appendChild(c),i.appendChild(a);let u=document.createElement("tbody");const p=s?t.slice(0,s):t;function f(d){u.innerHTML="",d.forEach((O,w)=>{let S=document.createElement("tr");S.style.backgroundColor=w%2===0?"#f9f9f9":"#fff",S.style.fontSize="0.9em",l.forEach((E,g)=>{let h=document.createElement("td");h.textContent=O[E],h.style.padding="5px",h.style.borderBottom="1px solid #ddd",h.style.textAlign="left",n&&(h.style.backgroundColor=g===0?"#444":void 0,h.style.color=g===0?"white":void 0),S.appendChild(h)}),u.appendChild(S)})}function m(d,O){p.sort((w,S)=>{let E=w[l[d]],g=S[l[d]];return!isNaN(parseFloat(E))&&!isNaN(parseFloat(g))?O?E-g:g-E:O?E.localeCompare(g):g.localeCompare(E)}),f(p)}f(p),i.appendChild(u);let y=document.createElement("div");return y.style.overflowY="auto",y.style.maxHeight="400px",y.style.margin="0",y.style.padding="0",y.style.boxSizing="border-box",y.style.overflowX="hidden",y.appendChild(i),setTimeout(()=>{const d=i.offsetWidth+20,O=y.offsetWidth;d>O?y.style.overflowX="scroll":(y.style.width=`${d}px`,y.style.overflowX="hidden")},0),y}function implantation(r){let s=Array.from(new Set(r.features.filter(i=>i!=null).filter(i=>i?.geometry!==null).map(i=>i?.geometry?.type))).filter(i=>i!=null),t=[];return(s.indexOf("Polygon")!==-1||s.indexOf("MultiPolygon")!==-1)&&t.push(3),(s.indexOf("LineString")!==-1||s.indexOf("MultiLineString")!==-1)&&t.push(2),(s.indexOf("Point")!==-1||s.indexOf("MultiPoint")!==-1)&&t.push(1),t.length==1?t[0]:-1}async function info(r){const s=(new Blob([JSON.stringify(r,null,2)],{type:"application/json"}).size/1024).toFixed(0),t=r.features.map(l=>l.geometry.coordinates).flat(4).filter(l=>l!==void 0).length/2,n=new Map([[1,"point"],[2,"line"],[3,"poly"]]),i=implantation(r),a=await geosloader();let c=[];return r.features.forEach((l,u)=>{if(isemptygeom(l?.geometry))c.push({index:u,isValid:0,reason:"empty"});else{const p=e(l,a);a.GEOSisEmpty(p)?c.push({index:u,isValid:0,reason:"empty"}):c.push({index:u,isValid:a.GEOSisValid(p),reason:a.GEOSisValidReason(p)}),a.GEOSFree(p)}}),c=c.filter(l=>l.isValid==0),c=c.length==0?"Valid Geometries":c,{type:n.get(i),geometries:geomtypes(r),diagnostic:c,properties:[...new Set(r?.features.map(l=>Object.keys(l?.properties)).flat())],weight:"~"+s+" KO",nodes:t}}function copy(r,{mutatebydefault:s=!1}={}){return structuredClone(r)}function dedupe(r,{key:s,mutate:t=!1}={}){let n=r;if(isgeojson(n)){t||(n=JSON.parse(JSON.stringify(r)));const i=[...new Set(n.features.map(c=>c?.properties[s]))];let a=[];i.forEach(c=>{a.push(n.features.find(l=>l?.properties[s]==c))}),n.features=a}else if(isarrayofobjects(n)){const i=[...new Set(n.map(c=>c[s]))];let a=[];i.forEach(c=>{a.push(n.find(l=>l[s]==c))}),n=a,t&&r.splice(0,r.length,...n)}return n}function table$1(r,{mutate:s=!1}={}){let t;if(s?t=r:t=structuredClone(r),isgeojson(t))return t?.features.map(n=>n?.properties);if(isarrayofobjects(t))return t}function combine(r,{fillkeys:s=!0}={}){if(r.every(t=>isgeojson(t))){let t=JSON.parse(JSON.stringify(r.map(n=>n.features).flat()));if(s){let n=[...new Set(t.map(i=>Object.keys(i.properties)).flat())];t.forEach(i=>{n.forEach(a=>{a in i.properties||(i.properties[a]=void 0)})})}return{type:"FeatureCollection",features:t}}else if(r.every(t=>isarrayofobjects(t))){let t=JSON.parse(JSON.stringify(r.flat()));if(s){let n=[...new Set(t.map(i=>Object.keys(i)).flat())];t=t.map(i=>Object.fromEntries(n.map(a=>[a,i[a]])))}return t}}function join(r,{ids:s,merge:t=!1,emptygeom:n=!0,all:i=!0,fillkeys:a=!0}={}){if(s==null)return combine(r);{if(r=r.map(l=>isgeojson(l)?structuredClone(l.features.map(u=>({...u?.properties,"#geometry#":u.geometry}))):structuredClone(l)),typeof s=="string"&&(s=Array(r.length).fill(s)),!t){let l=[];r.forEach(f=>{l.push([...new Set(f.map(m=>Object.keys(m)).flat())])});let u=uniqueIdentifiersNested(l);s=s.map((f,m)=>[f,u[m][l[m].indexOf(s[m])]]).map(f=>f[1]),r=renameKeysInArrays(r,u)}let c=r[0];for(let l=1;l<r.length;l++)c=mergeArrays(c,r[l],s[0],s[l],i);if(a){let l=[...new Set(c.map(u=>Object.keys(u)).flat())];c=c.map(u=>Object.fromEntries(l.map(p=>[p,u[p]])))}if([...new Set(c.map(l=>Object.keys(l)).flat())].includes("#geometry#")){n||(c=c.filter(p=>p["#geometry#"]!==void 0));const l=removeKeys(c,"#geometry#");c={type:"FeatureCollection",features:c.map((p,f)=>({type:"Feature",properties:l[f],geometry:p["#geometry#"]}))}}return c}}function uniqueIdentifiersNested(r){const s=new Map;return r.map(t=>t.map(n=>{if(n==="#geometry#")return n;const i="_".repeat(s.get(n)||0);return s.set(n,(s.get(n)||0)+1),i+n}))}function renameKeysInArrays(r,s){return r.map((t,n)=>t.map(i=>{let a={},c=s[n];return Object.keys(i).forEach((l,u)=>{let p=c[u]||l;a[p]=i[l]}),a}))}function mergeArrays(r,s,t,n,i){const a=r.map(c=>{const l=s.find(u=>{const p=c[t],f=u[n];return!isEmpty(p)&&!isEmpty(f)&&p===f});return l?{...c,...l}:{...c}});return i&&s.forEach(c=>{const l=c[n];r.some(u=>{const p=u[t];return!isEmpty(p)&&!isEmpty(l)&&p===l})||a.push({...c})}),a}function removeKeys(r,s){return r.map(t=>Object.fromEntries(Object.entries(t).filter(([n])=>!s.includes(n))))}function isEmpty(r){return r==null||r===""}async function derive(data,{key="_newkey",value,mutate=!1}={}){let x=data;const operators=/[+\-/*]/;if(isgeojson(data)){if(mutate||(x=JSON.parse(JSON.stringify(data))),typeof value=="number"||typeof value=="string"&&!operators.test(value))x.features.forEach(r=>{r.properties[key]=value});else if(typeof value=="function"){const r=await Promise.all(x.features.map(value));x.features.forEach((s,t)=>{s.properties[key]=r[t]})}else if(typeof value=="string"&&operators.test(value)){const prop=[...new Set(x.features.map(r=>r.properties).map(r=>Object.keys(r)).flat())],newprop=prop.map(r=>`d.properties['${r}']`),functrsing="d => "+prop.reduce((r,s,t)=>r.replace(new RegExp(s,"g"),newprop[t]),value),values=await Promise.all(x.features.map(eval(functrsing)));x.features.forEach((r,s)=>{r.properties[key]=values[s]})}}else if(isarrayofobjects(data)){if(typeof value=="number"||typeof value=="string"&&!operators.test(value))x.forEach(r=>{r[key]=value});else if(typeof value=="function"){const r=await Promise.all(x.map(value));x.forEach((s,t)=>{s[key]=r[t]})}else if(typeof value=="string"&&operators.test(value)){const prop=[...new Set(x.map(r=>Object.keys(r)).flat())],newprop=prop.map(r=>`d['${r}']`),functrsing="d => "+prop.reduce((r,s,t)=>r.replace(new RegExp(s,"g"),newprop[t]),value),values=await Promise.all(x.map(eval(functrsing)));x.forEach((r,s)=>{r[key]=values[s]})}mutate&&data.splice(0,data.length,...x)}return x}function filter(data,{func,mutate=!1}={}){let x=data;if(isgeojson(data)){if(mutate||(x=JSON.parse(JSON.stringify(data))),typeof func=="function")x.features=x.features.filter(func);else if(typeof func=="string"){const prop=[...new Set(x.features.map(r=>r.properties).map(r=>Object.keys(r)).flat())],newprop=prop.map(r=>"d.properties['"+r+"']");func="d => "+replaceEquals(addQuotesIfString(prop.reduce((r,s,t)=>r.replace(new RegExp(s,"g"),newprop[t]),func))),x.features=x.features.filter(eval(func))}}else if(isarrayofobjects(data)){if(typeof func=="function")x=x.filter(func);else if(typeof func=="string"){const prop=[...new Set(x.map(r=>Object.keys(r)).flat())],newprop=prop.map(r=>"d['"+r+"']"),func="d => "+replaceEquals(addQuotesIfString(prop.reduce((r,s,t)=>r.replace(new RegExp(s,"g"),newprop[t]),func)));x=x.filter(eval(func))}mutate&&data.splice(0,data.length,...x)}return x}function replaceEquals(r){return r.replace(new RegExp("(?<![><!])=(?![=])","g"),"==")}function addQuotesIfString(r){return r.replace(/([><=!]=?|==)\s*([A-Za-z_]+)/g,(s,t,n)=>`${t} '${n}'`)}function replace(r,{search:s="",replacement:t="",keys:n,mutate:i=!1}={}){let a;return i?a=r:a=JSON.parse(JSON.stringify(r)),isgeojson(a)?a.features.forEach(c=>{replaceinobj(c.properties,s,t,n)}):isarrayofobjects(a)&&(a.forEach(c=>{replaceinobj(c,s,t,n)}),i&&r.splice(0,r.length,...a)),a}function replaceinobj(r,s,t,n){let i=Object.entries(r);n!==void 0&&Array.isArray(n)&&(i=i.filter(a=>n.includes(a[0]))),i.forEach(([a,c])=>{typeof c=="string"&&(r[a]=c.replaceAll(s,t))})}function columns(r,{keys:s,rename:t,mutate:n=!1}={}){let i=r;if(isgeojson(i))if(n||(i=JSON.parse(JSON.stringify(r))),t!=null&&Array.isArray(t)&&t.length==s.length){const a=s.map((c,l)=>[c,t[l]]);i.features.forEach(c=>{c.properties=Object.fromEntries(a.map(l=>[l[1],c?.properties[l[0]]]))})}else s!==void 0&&Array.isArray(s)&&i.features.forEach(a=>{a.properties=Object.fromEntries(s.map(c=>[c,a?.properties[c]]))});else if(isarrayofobjects(i)){if(t!=null&&Array.isArray(t)&&t.length==s.length){const a=s.map((c,l)=>[c,t[l]]);i=i.map(c=>Object.fromEntries(a.map(l=>[l[1],c[l[0]]])))}else s!==void 0&&Array.isArray(s)&&(i=i.map(a=>Object.fromEntries(s.map(c=>[c,a[c]]))));n&&r.splice(0,r.length,...i)}return i}function stitch(r){const s=check(r);let t=s.import(r);return t=geoStitch(t),t.name="stitch",s.export(t)}function resolveemptygeom(r,{defaultype:s="Point"}={}){const t=check(r);let n=t.import(r),i;switch(implantation(n)){case 1:i="Point";break;case 2:i="LineString";break;case 3:i="Polygon";break;default:i=s}return n.features.map(a=>a.geometry=isemptygeom(a.geometry)?{type:i,coordinates:[]}:a.geometry),t.export(n)}function nodes(r){const s=check(r);let t=s.import(r),n=[];t.features.forEach(a=>{let c=a.geometry.coordinates.flat(1/0),l=[];for(let u=0;u<c.length;u=u+2)l.push({type:"Feature",properties:a.properties,geometry:{type:"Point",coordinates:[c[u],c[u+1]]}});n.push(l)});let i={type:"FeatureCollection",name:"nodes",features:n.flat()};return s.export(i)}function tissot(r=20){const s=geoCircle().center(n=>n).radius(r/4).precision(10),t=[];for(let n=-80;n<=80;n+=r)for(let i=-180;i<180;i+=r)t.push({type:"Feature",properties:{},geometry:{type:"MultiPolygon",coordinates:[s([i,n]).coordinates]}});return{type:"FeatureCollection",features:t}}function geolines(){let r=[];return[["Equator",0],["Tropic of Cancer",23.43656],["Tropic of Capricorn",-23.43636],["Arctic Circle",66.56345],["Antarctic Circle",-66.56364]].forEach(t=>{r.push({type:"Feature",properties:{name:t[0],latitude:t[1]},geometry:line(t[1])})}),{type:"FeatureCollection",features:r}}function line(r){let s=[],t=-180;for(;t<=180;)s.push([t,r]),t+=2.5;return{type:"MultiLineString",coordinates:[s]}}function roundcoordinates(r,{precision:s=2}={}){const t=check(r);let n=t.import(r),i=geojsonPrecisionExports.parse(n,s);return t.export(i)}function rewind2(r,{outer:s=!1}={}){const t=check(r);let n=t.import(r);for(let i=0;i<n.features.length;i++)if(n.features[i].geometry.type==="Polygon")rewindRings(n.features[i].geometry.coordinates,s);else if(n.features[i].geometry.type==="MultiPolygon")for(let a=0;a<n.features[i].geometry.coordinates.length;a++)rewindRings(n.features[i].geometry.coordinates[a],s);return t.export(n)}function rewindRings(r,s){if(r.length!==0){rewindRing(r[0],s);for(let t=1;t<r.length;t++)rewindRing(r[t],!s)}}function rewindRing(r,s){let t=0,n=0;for(let i=0,a=r.length,c=a-1;i<a;c=i++){const l=(r[i][0]-r[c][0])*(r[c][1]+r[i][1]),u=t+l;n+=Math.abs(t)>=Math.abs(l)?t-u+l:l-u+t,t=u}t+n>=0!=!!s&&r.reverse()}async function reverse(r,{dist:s=1,mutate:t=!1}={}){const n=await geosloader(),i=check(r);let a=i.import(r);return a.features.forEach(c=>{if(isemptygeom(c?.geometry))c.geometry=void 0;else{const l=e(c,n),u=n.GEOSReverse(l,s),p=o(u,n);c.geometry=p,n.GEOSFree(l),n.GEOSFree(u),n.GEOSFree(p)}}),i.export(a)}async function clip(r,{clip:s,reverse:t=!1}={}){if(s){const n=await geosloader(),i=check(r);let a=i.import(r);const c=n.GEOSUnaryUnion(e(check(s).import(s),n));let l=[];a.features.forEach(p=>{const f=e(p,n),m=t==!0?n.GEOSDifference(f,c):n.GEOSIntersection(f,c),y=o(m,n);isemptygeom(y)||l.push({type:"Feature",properties:p.properties,geometry:y}),n.GEOSFree(m)}),n.GEOSFree(c);const u={type:"FeatureCollection",name:"clip",features:l};return u.name="clip",i.export(u)}else return r}async function clipbyrect(r,{bbox:s=[90,180,-90,-180]}={}){const t=await geosloader(),n=check(r);let i=n.import(r);const a=e(i,t),c=t.GEOSClipByRect(a,s[3],s[2],s[1],s[0]);let l=o(c,t);return t.GEOSFree(a),t.GEOSFree(c),i.features=[{type:"Feature",properties:{},geometry:l}],i.name="clipbyrect",n.export(i)}async function makevalid(r){const s=await geosloader(),t=check(r);let n=t.import(r);return n.features.forEach(i=>{if(isemptygeom(i?.geometry))i.geometry=void 0;else{const a=e(i,s);if(s.GEOSisValid(a)!=1){const l=s.GEOSMakeValid(a);i.geometry=o(l,s),s.GEOSFree(a),s.GEOSFree(l)}}}),t.export(n)}async function densify(r,{dist:s=1,mutate:t=!1}={}){const n=await geosloader(),i=check(r);let a=i.import(r);return a.features.forEach(c=>{if(isemptygeom(c?.geometry))c.geometry=void 0;else{const l=e(c,n),u=n.GEOSDensify(l,s),p=o(u,n);c.geometry=p,n.GEOSFree(l),n.GEOSFree(u),n.GEOSFree(p)}}),a.name="densify",i.export(a)}async function union(r,{id:s}={}){const t=await geosloader(),n=check(r);let i=n.import(r);if(s){const a=[...new Set(i.features.map(l=>l.properties[s]))].filter(l=>!["",void 0,null,NaN,1/0,-1/0].includes(l)),c=new Map(a.map(l=>[l,{type:"FeatureCollection",features:i.features.filter(u=>u.properties[s]==l)}]));i.features=await Promise.all(a.map(async l=>{const u=e(c.get(l),t),p=t.GEOSUnaryUnion(u);let f={type:"Feature",properties:{id:l},geometry:o(p,t)};return t.GEOSFree(u),t.GEOSFree(p),f}))}else{const a=e(i,t),c=t.GEOSUnaryUnion(a);i.features=[{type:"Feature",properties:{},geometry:o(c,t)}],t.GEOSFree(a),t.GEOSFree(c)}return i.name="union",n.export(i)}async function concavehull(r,{ratio:s=0,holes:t=!0}={}){const n=await geosloader(),i=check(r);let a=i.import(r);const c=e(a,n),l=n.GEOSConcaveHull(c,s,t?1:0);let u=o(l,n);return n.GEOSFree(c),n.GEOSFree(l),i.export({type:"FeatureCollection",name:"concavehull",features:[{type:"Feature",properties:{},geometry:u}]})}async function convexhull(r){const s=await geosloader(),t=check(r);let n=t.import(r);const i=e(n,s),a=s.GEOSConvexHull(i);let c=o(a,s);return s.GEOSFree(i),s.GEOSFree(a),t.export({type:"FeatureCollection",name:"convexhull",features:[{type:"Feature",properties:{},geometry:c}]})}async function envelope(r){const s=await geosloader(),t=check(r);let n=t.import(r);const i=e(n,s),a=s.GEOSEnvelope(i);let c=o(a,s);return s.GEOSFree(i),s.GEOSFree(a),t.export({type:"FeatureCollection",features:[{type:"Feature",name:"envelope",properties:{},geometry:c}]})}async function contains(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSContains(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function covers(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSCovers(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function crosses(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSCrosses(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function disjoint(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSDisjoint(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function coveredby(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSCoveredBy(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function equals(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSEquals(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function intersects(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSIntersects(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function overlaps(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSOverlaps(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function touches(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSTouches(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function within(r,s){const t=await geosloader(),n=e(togeojson(r),t),i=e(togeojson(s),t),a=t.GEOSWithin(n,i);return t.GEOSFree(n),t.GEOSFree(i),result(a)}async function isvalid(r){const s=await geosloader(),t=e(togeojson(r),s),n=s.GEOSisValid(t);return s.GEOSFree(t),result(n)}async function isvalidreason(r){const s=await geosloader(),t=e(togeojson(r),s),n=s.GEOSisValidReason(t);return s.GEOSFree(t),n}function result(r){return new Map([[-1,void 0],[0,!1],[1,!0]]).get(r)}function coords2geo(r,s={}){let t=JSON.parse(JSON.stringify(r)),n=s.lat||s.latitude,i=s.lon||s.lng||s.longitude,a=s.coords||s.coordinates;(s.sep||s.separator)&&(s.sep||s.separator);let c=!!s.reverse;if(n==null&&i==null&&a==null){let l=["coords","Coords","coord","Coords","Coordinates","coordinates","Coordinate","coordinate"],u=["lat","Lat","LAT","Latitude","latitude"],p=["lon","Lon","LON","lng","Lng","LNG","Longitude","longitude"],f=[];t.forEach(m=>f.push(Object.keys(m))),f=Array.from(new Set(f.flat())),n=u.filter(m=>f.includes(m))[0],i=p.filter(m=>f.includes(m))[0],a=l.filter(m=>f.includes(m))[0]}if(n&&i){let l=c?i:n,u=c?n:i;return{type:"FeatureCollection",features:r.map(p=>({type:"Feature",properties:p,geometry:{type:"Point",coordinates:[+p[u],+p[l]]}}))}}return a&&{type:"FeatureCollection",features:r.map(l=>({type:"Feature",properties:l,geometry:{type:"Point",coordinates:c?getcoords(l[a]):getcoords(l[a]).reverse()}}))}}function txt2coords(r,s=","){r=r.replace(/[ ]+/g,"");let t=r.split(s).map(n=>n.replace(",",".")).map(n=>n.replace(/[^\d.-]/g,"")).map(n=>+n);return t.length!=2&&(t=[void 0,void 0]),t}function wkt2coords(r){let s=r.match(/\(([^)]+)\)/g);return s===null?[void 0,void 0]:s[0].replace(/\s\s+/g," ").replace("(","").replace(")","").trimStart().trimEnd().split(" ").map(t=>t.replace(",",".")).map(t=>+t)}function getcoords(r){return r?r.toLowerCase().includes("point")?wkt2coords(r):txt2coords(r):null}function add({x:r,field:s,expression:t}){let n=[...r.features.map(l=>({...l.properties}))],i=[];r.features.map(l=>l.properties).forEach(l=>{i.push(Object.keys(l))}),i=Array.from(new Set(i.flat())),i.forEach(l=>{t=t.replace(l,`d.${l}`)}),t="d=> "+t;let a=n.map(str2fun(t));n.forEach((l,u)=>{l=Object.assign(l,{[s]:a[u]})});let c=JSON.parse(JSON.stringify(r));return c.features.map((l,u)=>l.properties={...n[u]}),c}function select({x:r,expression:s}){let t=[...r.features],n=[];r.features.map(a=>a.properties).forEach(a=>{n.push(Object.keys(a))}),n=Array.from(new Set(n.flat())),n.forEach(a=>{s=s.replace(a,`d.properties.${a}`)}),s="d => "+s;let i=JSON.parse(JSON.stringify(r));return i.features=t.filter(str2fun(s)),i}function remove({x:r,field:s}){let t=[...r.features.map(i=>({...i.properties}))];t.forEach(i=>{Array.isArray(s)?s.forEach(a=>delete i[a]):delete i[s]});let n=JSON.parse(JSON.stringify(r));return n.features.map((i,a)=>i.properties={...t[a]}),n}function keep({x:r,fields:s}){let t=[];r.features.map(i=>i.properties).forEach(i=>{t.push(Object.keys(i))}),t=Array.from(new Set(t.flat()));let n=t.filter(i=>!s.includes(i));return remove({x:r,field:n})}function table(r){return JSON.parse(JSON.stringify(r.features.map(s=>s.properties)))}function subset({x:r,field:s,selection:t,inverse:n=!1}){let i=[...r.features];t=Array.isArray(t)?t:[t],n&&(t=Array.from(new Set(i.map(l=>l.properties[s]))).filter(l=>!t.includes(l)));let a=[];t.forEach(l=>{a.push(i.filter(u=>u.properties[s]==l))});let c=JSON.parse(JSON.stringify(r));return c.features=a.flat(),c}function head({x:r,field:s,nb:t=10}){let n=[...r.features];n=n.filter(a=>a.properties[s]!="").filter(a=>a.properties[s]!=null).filter(a=>a.properties[s]!=null).filter(a=>a.properties[s]!=1/0).filter(a=>a.properties[s]!=-1/0).filter(a=>a.properties[s]!=NaN),n.sort((a,c)=>+c.properties[s]-+a.properties[s]),n=n.slice(0,t);let i=JSON.parse(JSON.stringify(r));return i.features=n,i}function tail({x:r,field:s,nb:t=10}){let n=[...r.features];n=n.filter(a=>a.properties[s]!="").filter(a=>a.properties[s]!=null).filter(a=>a.properties[s]!=null).filter(a=>a.properties[s]!=1/0).filter(a=>a.properties[s]!=-1/0).filter(a=>a.properties[s]!=NaN),n.sort((a,c)=>+a.properties[s]-+c.properties[s]),n=n.slice(0,t);let i=JSON.parse(JSON.stringify(r));return i.features=n,i}let properties={add,select,keep,remove,table,subset,head,tail};export{F as aggregate,C as autotype,N as bbox,k as border,A as buffer,J as centroid,clip,clipbyrect,columns,combine,concavehull,contains,convexhull,coords2geo,copy,coveredby,covers,crosses,dedupe,densify,derive,disjoint,P as dissolve,envelope,equals,filter,geolines,I as groupby,M as head,htmltable,info,intersects,isvalid,isvalidreason,iterate,join,makevalid,nodes,overlaps,properties,L as removeemptygeom,replace,resolveemptygeom,reverse,R as rewind,rewind2,roundcoordinates,q as simplify,V as sort,stitch,table$1 as table,$ as tail,tissot,togeojson,touches,union,within};
